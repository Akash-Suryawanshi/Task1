#include <iostream>
#include "header.h"
#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include <fstream>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/bgsegm.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/video/background_segm.hpp>
#include <opencv2/imgproc/imgproc.hpp>

using namespace std;
using namespace cv;

double areaQueue(Mat img) {
	double ans = 0;
	for (int i = 0; i < img.rows; i++){
		for (int j = 0; j < img.cols; j++) {
			if(img.at<cv::Vec3b>(i,j)[0] == 255.0) {
				ans++;
			}
		}
	} 
	return ans/(img.rows * img.cols);
}
double areaDynamic(Mat img) {
	double ans = 0;
	for (int i = 0; i < img.rows; i++) {
		for (int j = 0; j < img.cols; j++) {
			if (img.at<cv::Vec3b>(i, j)[0] == 255.0) {
				ans++;
			}
		}
	}
	return ans / (img.rows * img.cols);
}

double calculate_area(vector< vector<Point> > contour, Mat img) {
	double tmp = 0;
	for(int i = 0; i < contour.size(); i++) {
			tmp += contourArea(contour[i]);
		}
	return tmp/(img.rows*img.cols);
}

pair<vector<double>,vector<double>> readVideo(string x) {
	VideoCapture cap(x);
	Mat fgMaskMOG2; //fg mask generated by MOG2 method
	vector<double> contourAreaDynamic;
	vector<double> contourAreaQueue;
	vector< vector<Point> > contours_Queue;
	vector< vector<Point> > contours_Dynamic;
	vector<Vec4i> hierarchy_Q;
	vector<Vec4i> hierarchy_D;
	Ptr<BackgroundSubtractor> pKNN; // MOG2 background subtractor
	double varThreshold = 50;
	pKNN = bgsegm::createBackgroundSubtractorGSOC(); // background subtractor objects
	Mat emptyBG0 = transform_and_crop(imread("emptyRoad.jpg"));
	Mat emptyBG;
	cvtColor(emptyBG0, emptyBG, COLOR_BGR2GRAY);
	ofstream MyFile("hull_Q.txt");
	int X = 3; // process every Xth frame
	while (1) {
		Mat frame; 
		cap >> frame;

		bool status;
		for(int i=0; i<X; i++){
			status = cap.read(frame);
		}

		if (frame.empty()) {
			break;
		}

		Mat croppedFrame = transform_and_crop(frame);
		pKNN->apply(croppedFrame, fgMaskMOG2);
		
		
		Mat diffImage;
		absdiff(emptyBG0,croppedFrame,diffImage);
		Mat foregroundMask = Mat::zeros(diffImage.rows, diffImage.cols, CV_8UC1);
		float threshold = 40.0f;
    	float dist;
		
		for(int j=0; j<diffImage.rows; ++j){
        	for(int i=0; i<diffImage.cols; ++i){
				cv::Vec3b pix = diffImage.at<cv::Vec3b>(j,i);
				dist = (pix[0]*pix[0] + pix[1]*pix[1] + pix[2]*pix[2]);
				dist = sqrt(dist);
				if(dist>threshold){            
					foregroundMask.at<unsigned char>(j,i) = 255;
				}
			}
		}
		findContours(foregroundMask, contours_Queue, hierarchy_Q, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0));
		findContours(fgMaskMOG2, contours_Dynamic, hierarchy_Q, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0));
		vector< vector<Point> > hull_Q(contours_Queue.size());
		vector< vector<Point> > hull_D(contours_Dynamic.size());
		for(int i = 0; i < contours_Queue.size(); i++){
			convexHull(Mat(contours_Queue[i]), hull_Q[i], false);
			}
		for(int i = 0; i < contours_Dynamic.size(); i++){
			convexHull(Mat(contours_Dynamic[i]), hull_D[i], false);
			}
		Mat drawing_Q = Mat::zeros(foregroundMask.size(), CV_8UC3);
		Mat drawing_D = Mat::zeros(fgMaskMOG2.size(), CV_8UC3);

		for(int i = 0; i < contours_Queue.size(); i++) {
			Scalar color_contours = Scalar(0, 255, 0);
			Scalar color = Scalar(255, 255, 255);
			drawContours(drawing_Q, contours_Queue, i, color_contours, 1, 8, vector<Vec4i>(), 0, Point());
			drawContours(drawing_Q, hull_Q, i, color, 1, 8, vector<Vec4i>(), 0, Point());
		}
		for(int i = 0; i < contours_Dynamic.size(); i++) {
			Scalar color_contours = Scalar(0, 255, 0);
			Scalar color = Scalar(255, 255, 255);
			drawContours(drawing_D, contours_Dynamic, i, color_contours, 1, 8, vector<Vec4i>(), 0, Point());
			drawContours(drawing_D, hull_D, i, color, 1, 8, vector<Vec4i>(), 0, Point());
		}
		double aq = calculate_area(contours_Queue, drawing_Q);
		double ad = calculate_area(contours_Dynamic, drawing_Q);
		contourAreaQueue.push_back(aq);
		MyFile << aq << endl;
		contourAreaDynamic.push_back(ad);
		imshow("Queue", drawing_Q);
		imshow("Dynamic", drawing_D);		

		// contourAreasQueue.push_back(areaQueue(foregroundMask));
		// contourAreasDynamic.push_back(areaDynamic(fgMaskMOG2));
		char c = (char)waitKey(25);
		if (c == 27) {
			break;
		} 
	}
	MyFile.close();
	cap.release();
	destroyAllWindows();
	return make_pair(contourAreaQueue,contourAreaDynamic);
}