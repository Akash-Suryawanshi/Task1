#include <iostream>
#include "header.h"
#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include <fstream>
#include <opencv2/bgsegm.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/video/background_segm.hpp>

using namespace std;
using namespace cv;

pair<vector<double>,vector<double>> readVideo(string x) {
	VideoCapture cap(x);
	Mat fgMaskMOG2; //fg mask generated by MOG2 method
	Ptr<BackgroundSubtractor> pKNN; // MOG2 background subtractor
	pKNN = bgsegm::createBackgroundSubtractorMOG(); // background subtractor objects
	
	// if (!cap.isOpened()) return;

	Mat emptyBG = transform_and_crop(imread("empty.jpg"));
	
	vector<vector<Point>> contours;
	vector<Vec4i> hierarchy;
	vector <vector<Point>> contoursD; // contours for difference img
	vector<Vec4i> hierarchyD;
	vector<double> contourAreasD;
	vector<double> contourAreas;	// countour areas per frame
	vector<double> time;
	double t = 0;
	while (1) {
		Mat frame; // current frame
		cap >> frame;

		if (frame.empty()) {
			break;
		}
		pKNN->apply(frame, fgMaskMOG2);
		Mat transform = transform_and_crop(fgMaskMOG2);
		imshow("FG MASK", transform);
		
		Mat diffImage;
		absdiff(emptyBG,transform,diffImage);
		findContours(diffImage, contoursD, hierarchyD, RETR_TREE, CHAIN_APPROX_SIMPLE);
		findContours(transform, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE);
		char c = (char)waitKey(25);
		if (c == 27) {
			break;
		}

	}
	cap.release();
	destroyAllWindows();
	// ofstream MyFile("Area.txt");
	for (auto c : contours) {
		// cout << contourArea(c) << endl;
		// MyFile << contourArea(c);
		time.push_back(t);
		contourAreas.push_back(contourArea(c));
		t += 1.0/15.0;
	}
	// MyFile.close();
	for (auto c : contoursD) {
		contourAreasD.push_back(contourArea(c));
	}

	return make_pair(contourAreas,contourAreasD);
}