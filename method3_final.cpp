#include <iostream>
#include "header.h"
#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include <fstream>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/bgsegm.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/video/background_segm.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <cstdlib>
#include <pthread.h>
#include <unistd.h>

using namespace std;
using namespace cv;

pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER; // mutex 1
pthread_mutex_t mutex2 = PTHREAD_MUTEX_INITIALIZER; // mutex 2

int rc;
vector<double> contourAreasQueue;
vector<double> contourAreasDynamic;	
double QueueAreaGlobal;
double DynamicAreaGlobal;
Ptr<BackgroundSubtractor> pKNN; // MOG2 background subtractor
double varThreshold = 50;
int niters = 4;
vector<Mat>blocks;
Mat emptyBG0; 
Mat emptyBG;

double areaQueue(Mat img) {
	double ans = 0;
	for (int i = 0; i < img.rows; i++){
		for (int j = 0; j < img.cols; j++) {
			if(img.at<cv::Vec3b>(i,j)[0] == 255.0) {
				ans++;
			}
		}
	} 
	return ans/(img.rows * img.cols)*1.25;
}
double areaDynamic(Mat img) {
	double ans = 0;
	for (int i = 0; i < img.rows; i++) {
		for (int j = 0; j < img.cols; j++) {
			if (img.at<cv::Vec3b>(i, j)[0] == 255.0) {
				ans++;
			}
		}
	}
	return ans / (img.rows * img.cols);
}

void *process(void *k){

	/*imshow("blocks",blocks[(long) k]);
	sleep(1);*/
	Mat croppedFrame = blocks[(long) k];
	/*resize(croppedFrame,croppedFrame, Size(1080,1920));
	croppedFrame = transform_and_crop(croppedFrame);*/
	cout << "YES\n";
	imshow("frame.jpg", croppedFrame);
	resize(croppedFrame, croppedFrame, Size(360, 240));

	Mat Dframe; //fg mask generated by MOG2 method
	
	pthread_mutex_lock(&mutex1);
	pKNN->apply(croppedFrame, Dframe);
	pthread_mutex_unlock(&mutex1);

	imshow("FG MASK", Dframe);


	Mat croppedFrame0 = croppedFrame;
	cvtColor(croppedFrame, croppedFrame0, COLOR_BGR2GRAY);
	GaussianBlur(croppedFrame0, croppedFrame0, Size(3, 3), 0);

	Mat diffImage0;
	absdiff(croppedFrame0, emptyBG,diffImage0);
	imshow("diffImage0", diffImage0);
		
	threshold(diffImage0, diffImage0, 50, 255, THRESH_BINARY);
    dilate(diffImage0, diffImage0, Mat(), Point(-1, -1), niters*2);
	imshow("diffImage0_after", diffImage0);
		
	Mat diffImage;
	absdiff(croppedFrame, emptyBG0,diffImage);
	Mat Qframe = Mat::zeros(diffImage.rows, diffImage.cols, CV_8UC1);
	float threshold = 77.0f;
    float dist;
	for(int j=0; j<diffImage.rows; ++j){
        for(int i=0; i<diffImage.cols; ++i){
			cv::Vec3b pix = diffImage.at<cv::Vec3b>(j,i);
			dist = (pix[0]*pix[0] + pix[1]*pix[1] + pix[2]*pix[2]);
			dist = sqrt(dist);
			if(dist>threshold){            
				Qframe.at<unsigned char>(j,i) = 255;
			}
		}
	}
	imshow("Difference Image", Qframe);
	
	double QueueArea = areaQueue(Qframe);
	double DynamicArea = areaDynamic(Dframe);
	QueueArea = max(QueueArea,DynamicArea);
	
	pthread_mutex_lock(&mutex2);
	QueueAreaGlobal += QueueArea;
	DynamicAreaGlobal += DynamicArea;
	pthread_mutex_unlock(&mutex2);

	pthread_exit(NULL);
}

pair<vector<double>,vector<double>> method3_final(string vid,int x){
	pthread_t threads[x];
	pthread_attr_t attr;
	void *status;

	VideoCapture cap(vid);
	pKNN = bgsegm::createBackgroundSubtractorGSOC(); // background subtractor objects
	// virtual void bgsegm::createBackgroundSubtractorMOG.setVarThreshold(varThreshold);
	Mat emt = imread("frame.jpg");
	emptyBG0 = transform_and_crop(emt);
	resize(emptyBG0, emptyBG0, Size(360, 240));
	cout << emptyBG0.size() << endl;
	cvtColor(emptyBG0, emptyBG, COLOR_BGR2GRAY);

	QueueAreaGlobal = 0.0;
	DynamicAreaGlobal = 0.0;

	while(1){
		Mat frame;
		cap >> frame;
		//divide this frame into x blocks and pass each block to each thread
		if(frame.empty()) break;
		//vector to store blocks
	    //img dimensions
	    int height = frame.rows;
	    int width = frame.cols;
	    cout << frame.size();
	    //required dims
	    int blockHeight = height/((int)sqrt(x));
	    int blockWidth = width/((int)sqrt(x));
	    //init blck dims
	    int Bheight;
	    int Bwidth;
	    int y0 = 0;
	    while(y0 < height){
	      Bheight = ((y0 + blockHeight) > height) * (blockHeight - (y0 + blockHeight - height)) + ((y0 + blockHeight) <= height) * blockHeight;
	      int x0 = 0;
	      while(x0 < width){
	        Bwidth = ((x0 + blockWidth) > width) * (blockWidth - (x0 + blockWidth - width)) + ((x0 + blockWidth) <= width) * blockWidth;
	        blocks.push_back(frame(Rect(x0, y0, Bwidth, Bheight)).clone());
	        x0 += blockWidth;
	      }
	      y0 += blockHeight;
	    }
	    //image is successfully divided
	    /*for(int i=0; i<blocks.size(); i++){
	        imshow("block " + to_string(i),blocks[i]);
	        waitKey(0);
	    }*/
	    pthread_attr_init(&attr);
   		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

		for(int i=0; i<x; i++){
			rc = pthread_create(&threads[i],&attr,process,(void *)i);
			cout << "Created Thread " << i << '\n';
			if(rc){
				cout << "Could not create thread\n";
				exit(1);
			}	
		}
		
		pthread_attr_destroy(&attr);
		for(int i=0; i<x; i++){
			cout << "Joined thread " << i << '\n'; 
			pthread_join(threads[i],&status);
		}

		cout << QueueAreaGlobal << ',' << DynamicAreaGlobal << '\n';

		contourAreasQueue.push_back(QueueAreaGlobal);
		contourAreasDynamic.push_back(DynamicAreaGlobal);

		char c = (char)waitKey(25);
		if (c == 27) {
			break;
		}
		blocks.clear();
	}
	cap.release();
	destroyAllWindows();
	
	pthread_exit(NULL);

	return make_pair(contourAreasQueue,contourAreasDynamic);
}